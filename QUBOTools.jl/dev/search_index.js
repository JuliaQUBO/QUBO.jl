var documenterSearchIndex = {"docs":
[{"location":"manual/3-usage/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"using QUBOTools","category":"page"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"By loading the package with the using statement, only a few constants will be dumped in the namespace, most of them model types.","category":"page"},{"location":"manual/3-usage/#File-I/O","page":"Basic Usage","title":"File I/O","text":"","category":"section"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"To read and write models one should use the QUBOTools.read_model/QUBOTools.write_model API.","category":"page"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"# File Path\npath = joinpath(@__DIR__, \"data\", \"problem.json\")\n\nmodel = QUBOTools.read_model(path)","category":"page"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"info: Info\nThe QUBOTools.read_model and QUBOTools.write_model methods will try to infer the file format from the file extension. The format can be manually set by passing an extra optional parameter after the source path. For more information, see File Formats.","category":"page"},{"location":"manual/3-usage/#Data-Access","page":"Basic Usage","title":"Data Access","text":"","category":"section"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"QUBOTools.description(model)","category":"page"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"QUBOTools.linear_terms(model) |> collect","category":"page"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"QUBOTools.quadratic_terms(model) |> collect","category":"page"},{"location":"manual/3-usage/#Model-Analysis","page":"Basic Usage","title":"Model Analysis","text":"","category":"section"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"QUBOTools.density(model)","category":"page"},{"location":"manual/3-usage/#File-formats","page":"Basic Usage","title":"File formats","text":"","category":"section"},{"location":"manual/3-usage/#Conversion-between-formats","page":"Basic Usage","title":"Conversion between formats","text":"","category":"section"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"One of the main functionalities of this package is to allow fast conversion from a QUBO file format to another. Achieving this is as simple as writing the loaded model but providing a different specification:","category":"page"},{"location":"manual/3-usage/","page":"Basic Usage","title":"Basic Usage","text":"QUBOTools.write_model(stdout, model, QUBOTools.Qubist())","category":"page"},{"location":"formats/QUBO/#QUBO","page":"QUBO","title":"QUBO","text":"","category":"section"},{"location":"formats/QUBO/#Format","page":"QUBO","title":"Format","text":"","category":"section"},{"location":"formats/QUBO/","page":"QUBO","title":"QUBO","text":"QUBOTools.QUBO","category":"page"},{"location":"formats/QUBO/#QUBOTools.QUBO","page":"QUBO","title":"QUBOTools.QUBO","text":"QUBO()\nQUBO(style::Symbol)\n\n\n\n\n\n","category":"type"},{"location":"formats/MiniZinc/#MiniZinc","page":"MiniZinc","title":"MiniZinc","text":"","category":"section"},{"location":"formats/MiniZinc/#Format","page":"MiniZinc","title":"Format","text":"","category":"section"},{"location":"formats/MiniZinc/","page":"MiniZinc","title":"MiniZinc","text":"QUBOTools.MiniZinc","category":"page"},{"location":"formats/MiniZinc/#QUBOTools.MiniZinc","page":"MiniZinc","title":"QUBOTools.MiniZinc","text":"MiniZinc\n\n\n\n\n\n","category":"type"},{"location":"manual/4-models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"manual/4-models/","page":"Models","title":"Models","text":"This package defines QUBOTools.AbstractModel as an abstract type for QUBO models. V is a type for representing variables, usually an integer or string-like type. The problem's coefficients are stored under the T type, that also represents the energy values corresponding to each solution. When solution state vectors are sampled, their entries will be of the integer type U. Since values are binary, using integer types smaller than Int64 is a reasonable choice.","category":"page"},{"location":"manual/4-models/#Reference-Implementation","page":"Models","title":"Reference Implementation","text":"","category":"section"},{"location":"manual/4-models/","page":"Models","title":"Models","text":"QUBOTools also exports the QUBOTools.Model type, designed to work as standard backend for other applications to be built atop.","category":"page"},{"location":"manual/4-models/#Model-Backend","page":"Models","title":"Model Backend","text":"","category":"section"},{"location":"manual/4-models/","page":"Models","title":"Models","text":"using QUBOTools\n\nmutable struct SuperModel{V,T,U} <: QUBOTools.AbstractModel{V,T,U}\n    model::QUBOTools.Model{V,T,U}\n    super::Bool\n\n    function SuperModel{V,T,U}() where {V,T,U}\n        return new(QUBOTools.Model{V,T,U}(), true)\n    end\nend\n\nQUBOTools.backend(model::SuperModel) = model.model","category":"page"},{"location":"manual/4-models/","page":"Models","title":"Models","text":"model = SuperModel{Symbol,Float64,Int}()","category":"page"},{"location":"manual/4-models/#JuMP-Integration","page":"Models","title":"JuMP Integration","text":"","category":"section"},{"location":"manual/4-models/","page":"Models","title":"Models","text":"One of the main milestones was to make JuMP / MathOptInterface integration easy. When V is set to MOI.VariableIndex and T matches Optimzer{T}, the QUBOTools backend is able to handle most of the data management workload.","category":"page"},{"location":"manual/1-start/#Manual","page":"Introduction","title":"Manual","text":"","category":"section"},{"location":"manual/1-start/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"manual/1-start/","page":"Introduction","title":"Introduction","text":"This manual aims to explain the fundamental concepts behind loading, manipulating and analyzing models with QUBOTools.","category":"page"},{"location":"manual/1-start/#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"manual/1-start/","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"2-math.md\",\n    \"3-usage.md\",\n    \"4-models.md\",\n    \"5-formats\",\n    \"6-solutions.md\",\n    \"7-analysis.md\"\n]\nDepth = 2","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Fallback-dispatch","page":"API Reference","title":"Fallback dispatch","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"When extending QUBOTools, one might want to implement a method for QUBOTools.backend.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.backend","category":"page"},{"location":"api/#QUBOTools.backend","page":"API Reference","title":"QUBOTools.backend","text":"backend(model)::AbstractModel\nbackend(model::AbstractModel)::AbstractModel\n\nAccesses the model's backend. Implementing this function allows one to profit from fallback implementations of other methods.\n\n\n\n\n\n","category":"function"},{"location":"api/#Variable-System","page":"API Reference","title":"Variable System","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.index\nQUBOTools.indices\nQUBOTools.hasindex\nQUBOTools.variable\nQUBOTools.variables\nQUBOTools.hasvariable","category":"page"},{"location":"api/#QUBOTools.index","page":"API Reference","title":"QUBOTools.index","text":"index(model::AbstractModel{V}, v::V) where {V}\n\nGiven a variable, returns the corresponding index.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.indices","page":"API Reference","title":"QUBOTools.indices","text":"indices(model)\n\nReturns a sorted vector 1 dots n that matches the variable indices, where n is the model's dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.hasindex","page":"API Reference","title":"QUBOTools.hasindex","text":"hasindex(model::AbstractModel, i::Integer)::Bool\n\nGiven an index, returns whether it is valid for rhe model.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.variable","page":"API Reference","title":"QUBOTools.variable","text":"variable(model::AbstractModel, i::Integer)\n\nGiven an index, returns the corresponding variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.variables","page":"API Reference","title":"QUBOTools.variables","text":"variables(model)\n\nReturns a sorted vector containing the model's variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.hasvariable","page":"API Reference","title":"QUBOTools.hasvariable","text":"hasvariable(model::AbstractModel{V}, v::V)::Bool where {V}\n\nGiven a variable, tells if it belongs to the model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.VariableMap","category":"page"},{"location":"api/#QUBOTools.VariableMap","page":"API Reference","title":"QUBOTools.VariableMap","text":"VariableMap{V}\n\nEstablishes a bijection between variables and their indices. The interface for accessing this mapping relies on QUBOTools.index and QUBOTools.variable.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.PBO.varlt","category":"page"},{"location":"api/#PseudoBooleanOptimization.varlt","page":"API Reference","title":"PseudoBooleanOptimization.varlt","text":"varlt(u::V, v::V) where {V}\n\nCompares two variables, u and v, with respect to their length-lexicographic order.\n\nRationale\n\nThis function exists to define an arbitrary ordering for a given type and was created to address [MOI]. There is no predefined comparison between instances MOI's VariableIndex type.\n\n[^MOI]: MathOptInterface Issue [#1985](https://github.com/jump-dev/MathOptInterface.jl/issues/1985)\n\n\n\n\n\n","category":"function"},{"location":"api/#Objective-and-Domain-Frames","page":"API Reference","title":"Objective & Domain Frames","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.Domain\nQUBOTools.BoolDomain\nQUBOTools.SpinDomain\nQUBOTools.domain","category":"page"},{"location":"api/#QUBOTools.Domain","page":"API Reference","title":"QUBOTools.Domain","text":"Domain\n\nEnum representing binary variable domains, BoolDomain and SpinDomain.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.BoolDomain","page":"API Reference","title":"QUBOTools.BoolDomain","text":"BoolDomain\n\nRepresents the boolean domain mathbbB = lbrace0 1rbrace.\n\nProperties\n\nx in mathbbB n in mathbbN implies x^n = x\n\n\n\n\n\n","category":"constant"},{"location":"api/#QUBOTools.SpinDomain","page":"API Reference","title":"QUBOTools.SpinDomain","text":"SpinDomain\n\nRepresents the spin domain mathbbS = lbrace-1 1rbrace.\n\nProperties\n\ns in mathbbS n in mathbbZ implies s^2n = 1 s^2n + 1 = s\n\n\n\n\n\n","category":"constant"},{"location":"api/#QUBOTools.domain","page":"API Reference","title":"QUBOTools.domain","text":"domain(model::AbstractModel)\n\nReturns the variable domain of a given model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.Sense\nQUBOTools.sense","category":"page"},{"location":"api/#QUBOTools.Sense","page":"API Reference","title":"QUBOTools.Sense","text":"Sense\n\nEnum representing the minimization and maximization objective senses, Min and Max.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.sense","page":"API Reference","title":"QUBOTools.sense","text":"sense(model)\n\nReturns the objective sense of a model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.Frame\nQUBOTools.frame\nQUBOTools.cast","category":"page"},{"location":"api/#QUBOTools.Frame","page":"API Reference","title":"QUBOTools.Frame","text":"Frame(sense::Sense, domain::Domain)\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.frame","page":"API Reference","title":"QUBOTools.frame","text":"frame(model)\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.cast","page":"API Reference","title":"QUBOTools.cast","text":"Recasting the sense of a model preserves its meaning but the linear terms, quadratic terms and constant offset of a model will have its signs reversed, so does the overall objective function.\n\nbeginarrayll\n    min_s alpha f(s) + beta equiv max_s -alpha f(s) + beta \n                                   equiv max_s alpha -f(s) - beta \nendarray\n\nwarn: Warn\nCasting to the same (sense, domain) frame is a no-op. That means that no copying will take place automatically, and therefore copy should be called explicitly when necessary.\n\n\n\n\n\n","category":"function"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.CastingError","category":"page"},{"location":"api/#QUBOTools.CastingError","page":"API Reference","title":"QUBOTools.CastingError","text":"CastingError\n\nError while casting data between domains or senses.\n\n\n\n\n\n","category":"type"},{"location":"api/#Models","page":"API Reference","title":"Models","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractModel\nQUBOTools.Model","category":"page"},{"location":"api/#QUBOTools.AbstractModel","page":"API Reference","title":"QUBOTools.AbstractModel","text":"AbstractModel{V,T,U}\n\nRepresents an abstract QUBO Model.\n\nAs shown in the example above, implementing a method for the QUBOTools.backend function gives access to most fallback implementations.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.Model","page":"API Reference","title":"QUBOTools.Model","text":"Model{V,T,U,F<:AbstractForm{T}} <: AbstractModel{V,T,U}\n\nReference AbstractModel implementation. It is intended to be the stardard in-memory representation for QUBO models.\n\nMathOptInterface/JuMP Integration\n\nBoth V and T parameters exist to support MathOptInterface/JuMP integration. This is made possible by choosing V to match MOI.VariableIndex and T as in Optimizer{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Forms","page":"API Reference","title":"Model Forms","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractForm\nQUBOTools.AbstractLinearForm\nQUBOTools.AbstractQuadraticForm\nQUBOTools.form\nQUBOTools.linear_form\nQUBOTools.quadratic_form","category":"page"},{"location":"api/#QUBOTools.AbstractForm","page":"API Reference","title":"QUBOTools.AbstractForm","text":"AbstractForm{T}\n\nA form is a 7-tuple (n ell Q alpha beta) times (textrmsense textrmdomain) representing a QUBO / Ising model.\n\nn, the dimension, is the number of variables.\nmathbfell, the linear form, represents a vector storing the linear terms.\nmathbfQ, the quadratic form, represents an upper triangular matrix containing the quadratic interactions.\nalpha is the scale factor, defaults to 1.\nbeta is the offset factor, defaults to 0.\n\nThe inner data structures used to represent each of these elements may vary.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.AbstractLinearForm","page":"API Reference","title":"QUBOTools.AbstractLinearForm","text":"AbstractLinearForm{T}\n\nLinear form subtypes will create a wrapper around data structures for representing the linear terms mathbfellmathbfx of the QUBO model.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.AbstractQuadraticForm","page":"API Reference","title":"QUBOTools.AbstractQuadraticForm","text":"AbstractQuadraticForm{T}\n\nQuadratic form subtypes will create a wrapper around data structures for representing the quadratic terms mathbfxmathbfQmathbfx of the QUBO model.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.form","page":"API Reference","title":"QUBOTools.form","text":"form(src [, formtype::Type{<:AbstractForm{T}}]; sense, domain) where {T}\nform(src [, formtype::Union{Symbol,Type}, T::Type = Float64]; sense, domain)\n\nReturns the QUBO form stored within src, casting it to the corresponding (sense, domain) frame and, if necessary, converting the coefficients to type T.\n\nThe underlying data structure is given by formtype. Current options include :dict, :dense and :sparse.\n\nFor more informaion, see QUBOTools.Form and QUBOTools.AbstractForm.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.linear_form","page":"API Reference","title":"QUBOTools.linear_form","text":"linear_form(Φ::F) where {T,F<:AbstractForm{T}}\n\nReturns the linear part of the QUBO form.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.quadratic_form","page":"API Reference","title":"QUBOTools.quadratic_form","text":"quadratic_form(Φ::F) where {T,F<:AbstractForm{T}}\n\nReturns the quadratic part of the QUBO form.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.qubo\nQUBOTools.ising","category":"page"},{"location":"api/#QUBOTools.qubo","page":"API Reference","title":"QUBOTools.qubo","text":"qubo(args; kws...)\n\nThis function is a shorthand for form(args...; kws..., domain = :bool).\n\nFor more informaion, see QUBOTools.form.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.ising","page":"API Reference","title":"QUBOTools.ising","text":"ising(args; kws...)\n\nThis function is a shorthand for form(args...; kws..., domain = :spin).\n\nFor more informaion, see QUBOTools.form.\n\n\n\n\n\n","category":"function"},{"location":"api/#Underlying-Data-Structures","page":"API Reference","title":"Underlying Data Structures","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.Form\nQUBOTools.formtype","category":"page"},{"location":"api/#QUBOTools.Form","page":"API Reference","title":"QUBOTools.Form","text":"Form{T,LF,LQ}\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.formtype","page":"API Reference","title":"QUBOTools.formtype","text":"formtype(spec::Type)\nformtype(spec::Symbol)\n\nReturns a form type according to the given specification.\n\nformtype(src)\n\nReturns the form type of a form or model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.DictForm\nQUBOTools.DictLinearForm\nQUBOTools.DictQuadraticForm","category":"page"},{"location":"api/#QUBOTools.DictForm","page":"API Reference","title":"QUBOTools.DictForm","text":"DictForm{T}\n\nThis QUBO form is built using dictionaries for both the linear and quadratic terms.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.DictLinearForm","page":"API Reference","title":"QUBOTools.DictLinearForm","text":"DictLinearForm{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.DictQuadraticForm","page":"API Reference","title":"QUBOTools.DictQuadraticForm","text":"DictQuadraticForm{T}\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.DenseForm\nQUBOTools.DenseLinearForm\nQUBOTools.DenseQuadraticForm","category":"page"},{"location":"api/#QUBOTools.DenseForm","page":"API Reference","title":"QUBOTools.DenseForm","text":"DenseForm{T}\n\nThis QUBO form is built using a vector for the linear terms and a matrix for storing the quadratic terms.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.DenseLinearForm","page":"API Reference","title":"QUBOTools.DenseLinearForm","text":"DenseLinearForm{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.DenseQuadraticForm","page":"API Reference","title":"QUBOTools.DenseQuadraticForm","text":"DenseQuadraticForm{T}\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.SparseForm\nQUBOTools.SparseLinearForm\nQUBOTools.SparseQuadraticForm","category":"page"},{"location":"api/#QUBOTools.SparseForm","page":"API Reference","title":"QUBOTools.SparseForm","text":"SparseForm{T}\n\nThis QUBO form is built using a sparse vector for the linear terms and a sparse matrix for the quadratic ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.SparseLinearForm","page":"API Reference","title":"QUBOTools.SparseLinearForm","text":"SparseLinearForm{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.SparseQuadraticForm","page":"API Reference","title":"QUBOTools.SparseQuadraticForm","text":"SparseQuadraticForm{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#Solutions","page":"API Reference","title":"Solutions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.State","category":"page"},{"location":"api/#QUBOTools.State","page":"API Reference","title":"QUBOTools.State","text":"State\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractSample\nQUBOTools.Sample\nQUBOTools.sample\nQUBOTools.hassample","category":"page"},{"location":"api/#QUBOTools.AbstractSample","page":"API Reference","title":"QUBOTools.AbstractSample","text":"AbstractSample\n\nA sample is a triple (psi lambda r) where psi in mathbbU^n sim mathbbB^n is the sampled vector, lambda in mathbbR is the associated energy value and r in mathbbN is the number of reads, i. e., the multiplicity of the sample.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.Sample","page":"API Reference","title":"QUBOTools.Sample","text":"Sample{T,U}(state::Vector{U}, value::T, reads::Integer = 1) where{T,U}\n\nThis is the reference implementation for QUBOTools.AbstractSample.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.sample","page":"API Reference","title":"QUBOTools.sample","text":"sample(model, i::Integer)\n\nReturns the i-th sample on the model's current solution, if available.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.hassample","page":"API Reference","title":"QUBOTools.hassample","text":"hassample(solution::AbstractSolution, i::Integer)\n\nTells if the i-th sample is available on the solution.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractSolution\nQUBOTools.SampleSet\nQUBOTools.solution","category":"page"},{"location":"api/#QUBOTools.AbstractSolution","page":"API Reference","title":"QUBOTools.AbstractSolution","text":"AbstractSolution\n\nBy definitioon, a solution is an ordered set of samples.\n\nSee QUBOTools.AbstractSample.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.SampleSet","page":"API Reference","title":"QUBOTools.SampleSet","text":"SampleSet{T,U}(\n    data::Vector{Sample{T,U}},\n    metadata::Union{Dict{String,Any},Nothing} = nothing;\n    sense::Union{Sense,Symbol}   = :min,\n    domain::Union{Domain,Symbol} = :bool,\n) where {T,U}\n\nReference implementation of QUBOTools.AbstractSolution.\n\nIt was inspired by D-Wave's SampleSet[dwave], with a few tweaks. For example, samples are automatically sorted upon instantiation and repeated samples are merged by adding up their reads field. Also, the solution frame is stored, allowing for queries and cast operations.\n\n[dwave]: D-Wave Ocean SDK {docs}\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.solution","page":"API Reference","title":"QUBOTools.solution","text":"solution(model) where {T,U<:Integer}\n\nReturns the model's current solution.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.state\nQUBOTools.value\nQUBOTools.energy\nQUBOTools.reads","category":"page"},{"location":"api/#QUBOTools.state","page":"API Reference","title":"QUBOTools.state","text":"state(sample::AbstractSample{T,U}) where {T,U<:Integer}\n\nReturns a vector containing the assingment of each variable in a sample.\n\nstate(model, i::Integer) where {U<:Integer}\n\nReturns a vector corresponding to the bitstring of the i-th sample on the model's current solution, if available.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.value","page":"API Reference","title":"QUBOTools.value","text":"value(model)::T where {T}\n\nvalue(model, i::Integer)::T where {T}\nvalue(solution::AbstractSolution{T,U}, i::Integer)::T where {T,U}\n\nvalue(model, state::AbstractVector{U}) where {U<:Integer}\nvalue(solution::AbstractSolution{T,U}, state::AbstractVector{U})::T where {T,U<:Integer}\n\nvalue(Q::Dict{Tuple{Int,Int},T}, ψ::Vector{U}, α::T = one(T), β::T = zero(T)) where {T}\nvalue(h::Dict{Int,T}, J::Dict{Tuple{Int,Int},T}, ψ::Vector{U}, α::T = one(T), β::T = zero(T)) where {T}\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.energy","page":"API Reference","title":"QUBOTools.energy","text":"energy\n\nAn alias for value.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.reads","page":"API Reference","title":"QUBOTools.reads","text":"reads(model)\nreads(solution::AbstractSolution)\n\nReturns the total amount of reads from each sample, combined.\n\nreads(model, i::Integer)\nreads(solution::AbstractSolution, i::Integer)\n\nReturns the sampling frequency of the i-th sample on the model's current solution, if available.\n\n\n\n\n\n","category":"function"},{"location":"api/#Solution-Errors","page":"API Reference","title":"Solution Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.SolutionError","category":"page"},{"location":"api/#QUBOTools.SolutionError","page":"API Reference","title":"QUBOTools.SolutionError","text":"SolutionError\n\nError occurred while gathering solutions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Data-Access","page":"API Reference","title":"Data Access","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.linear_terms\nQUBOTools.quadratic_terms\nQUBOTools.scale\nQUBOTools.offset","category":"page"},{"location":"api/#QUBOTools.linear_terms","page":"API Reference","title":"QUBOTools.linear_terms","text":"linear_terms(model::AbstractModel{V,T,U}) where {V,T,U}\n\nReturns an iterator for the linear nonzero terms of a model as Int => T pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.quadratic_terms","page":"API Reference","title":"QUBOTools.quadratic_terms","text":"quadratic_terms(model::AbstractModel{V,T,U}) where {V,T,U}\n\nReturns an iterator for the quadratic nonzero terms of a model as Tuple{Int,Int} => T pairs.\n\ninfo: Info\nFor every key pair (i j) we have that i  j.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.scale","page":"API Reference","title":"QUBOTools.scale","text":"scale(model::AbstractModel)\nscale(model::AbstractForm)\n\nReturns the scaling factor of a model.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.offset","page":"API Reference","title":"QUBOTools.offset","text":"offset(model::AbstractModel)\noffset(model::AbstractForm)\n\nReturns the constant offset factor of a model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.data","category":"page"},{"location":"api/#QUBOTools.data","page":"API Reference","title":"QUBOTools.data","text":"data(form)\ndata(sol::AbstractSolution)\n\nRetrieves the raw data behind solution and form wrappers.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.metadata\nQUBOTools.id\nQUBOTools.description","category":"page"},{"location":"api/#QUBOTools.metadata","page":"API Reference","title":"QUBOTools.metadata","text":"metadata(model::AbstractModel)\nmetadata(sol::AbstractSolution)\n\nRetrieves metadata from a model or solution as a JSON-compatible Dict{String,Any}.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.id","page":"API Reference","title":"QUBOTools.id","text":"id(model)\n\nReturns a model identifier as an Int or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.description","page":"API Reference","title":"QUBOTools.description","text":"description(model)\n\nReturns the model description as a String or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.start","category":"page"},{"location":"api/#QUBOTools.start","page":"API Reference","title":"QUBOTools.start","text":"start(model::AbstractModel{V,T,U}; domain = domain(model))::Dict{Int,U} where {V,T,U}\n\nReturns a dictionary containing a warm-start value for each variable index.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.attach!","category":"page"},{"location":"api/#QUBOTools.attach!","page":"API Reference","title":"QUBOTools.attach!","text":"attach!(model::AbstractModel{V,T,U}, sol::AbstractSolution{T,U}) where {V,T,U}\n\nAttaches solution to model, replacing existing data and solution metadata. It automatically casts the solution to the model frame upon attachment.\n\n\n\n\n\n","category":"function"},{"location":"api/#File-Formats-and-I/O","page":"API Reference","title":"File Formats & I/O","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractFormat\nQUBOTools.format\nQUBOTools.version","category":"page"},{"location":"api/#QUBOTools.AbstractFormat","page":"API Reference","title":"QUBOTools.AbstractFormat","text":"AbstractFormat\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.format","page":"API Reference","title":"QUBOTools.format","text":"format(::AbstractString)::AbstractFormat\nformat(::Symbol)::AbstractFormat\nformat(::Symbol, ::Symbol)::AbstractFormat\n\nGiven the file path, tries to infer the type associated to a QUBO model format.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.version","page":"API Reference","title":"QUBOTools.version","text":"version(fmt::AbstractFormat)\n\nReturns the version of a format protocol as a VersionNumber or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.read_model\nQUBOTools.write_model","category":"page"},{"location":"api/#QUBOTools.read_model","page":"API Reference","title":"QUBOTools.read_model","text":"read_model(::AbstractString)\nread_model(::AbstractString, ::AbstractFormat)\nread_model(::IO, ::AbstractFormat)\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.write_model","page":"API Reference","title":"QUBOTools.write_model","text":"write_model(::AbstractString, ::AbstractModel)\nwrite_model(::AbstractString, ::AbstractModel, ::AbstractFormat)\nwrite_model(::IO, ::AbstractModel, ::AbstractFormat)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.read_solution\nQUBOTools.write_solution","category":"page"},{"location":"api/#QUBOTools.read_solution","page":"API Reference","title":"QUBOTools.read_solution","text":"read_solution(::AbstractString)\nread_solution(::AbstractString, ::AbstractFormat)\nread_solution(::IO, ::AbstractFormat)\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.write_solution","page":"API Reference","title":"QUBOTools.write_solution","text":"write_solution(::AbstractString, ::AbstractSolution)\nwrite_solution(::AbstractString, ::AbstractSolution, ::AbstractFormat)\nwrite_solution(::IO, ::AbstractSolution, ::AbstractFormat)\n\n\n\n\n\n","category":"function"},{"location":"api/#Format-and-I/O-Errors","page":"API Reference","title":"Format & I/O Errors","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.FormatError\nQUBOTools.SyntaxError","category":"page"},{"location":"api/#QUBOTools.FormatError","page":"API Reference","title":"QUBOTools.FormatError","text":"FormatError\n\nError related to the format specification.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.SyntaxError","page":"API Reference","title":"QUBOTools.SyntaxError","text":"SyntaxError\n\nSyntax error while parsing file.\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-Metrics","page":"API Reference","title":"Model Metrics","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.dimension\nQUBOTools.linear_size\nQUBOTools.quadratic_size\nQUBOTools.density\nQUBOTools.linear_density\nQUBOTools.quadratic_density","category":"page"},{"location":"api/#QUBOTools.dimension","page":"API Reference","title":"QUBOTools.dimension","text":"dimension(model)::Integer\n\nCounts the total number of variables in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.linear_size","page":"API Reference","title":"QUBOTools.linear_size","text":"linear_size(model)\n\nCounts the number of non-zero linear terms in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.quadratic_size","page":"API Reference","title":"QUBOTools.quadratic_size","text":"quadratic_size(model)\n\nCounts the number of non-zero quadratic terms in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.density","page":"API Reference","title":"QUBOTools.density","text":"density(model)::Float64\n\nComputes the density rho of non-zero terms in a model, according to the expression[qplib]\n\nrho = fracn_ell + 2 n_qn^2\n\nwhere n_ell is the number of non-zero linear terms, n_q the number of quadratic ones and n the number of variables.\n\nIf the model is empty, returns NaN.\n\n[qplib]: QPLIB: A Library of Quadratic Programming Instances {docs}\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.linear_density","page":"API Reference","title":"QUBOTools.linear_density","text":"linear_density(model)::Float64\n\nComputes the linear density rho_ell, given by\n\nrho_ell = fracn_elln\n\nwhere n_ell is the number of non-zero linear terms and n the number of variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.quadratic_density","page":"API Reference","title":"QUBOTools.quadratic_density","text":"quadratic_density(model)::Float64\n\nComputes the quadratic density rho_q, given by\n\nrho_q = frac2 n_qn (n - 1)\n\nwhere n_q is the number of non-zero quadratic terms and n the number of variables.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.topology\nQUBOTools.adjacency\nQUBOTools.geometry","category":"page"},{"location":"api/#QUBOTools.topology","page":"API Reference","title":"QUBOTools.topology","text":"topology(model)\n\nReturns a Graphs.jl-compatible graph representing the quadratic interactions between variables in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.adjacency","page":"API Reference","title":"QUBOTools.adjacency","text":"adjacency(model)\n\nAn alias for topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.geometry","page":"API Reference","title":"QUBOTools.geometry","text":"geometry\n\nReturns a n times N matrix describing the placement of the n variable sites in N-dimensional space.\n\n\n\n\n\n","category":"function"},{"location":"api/#System-Specification","page":"API Reference","title":"System Specification","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractArchitecture\nQUBOTools.GenericArchitecture\nQUBOTools.architecture","category":"page"},{"location":"api/#QUBOTools.AbstractArchitecture","page":"API Reference","title":"QUBOTools.AbstractArchitecture","text":"AbstractArchitecture\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.GenericArchitecture","page":"API Reference","title":"QUBOTools.GenericArchitecture","text":"GenericArchitecture()\n\nThis type is used to reach fallback implementations for AbstractArchitecture.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.architecture","page":"API Reference","title":"QUBOTools.architecture","text":"architecture(::Any)\n\nIt should be defined to provide automatic architecture recognition when writing QUBO Solver interfaces.\n\nExample\n\nstruct Solver\n    ...\nend\n\nstruct SolverArchitecture <: AbstractArchitecture\n    ...\nend\n\narchitecture(::Solver) = SolverArchitecture()\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractDevice\nQUBOTools.GenericDevice","category":"page"},{"location":"api/#QUBOTools.AbstractDevice","page":"API Reference","title":"QUBOTools.AbstractDevice","text":"AbstractDevice{A<:AbstractArchitecture,V,T,U} <: AbstractModel{V,T,U}\n\nA device instance is meant to represent an specific hardware or software device. It is the concrete implementation of an architecture. For example, the topology of a device must be contained within the ideal topology of its architecture.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.GenericDevice","page":"API Reference","title":"QUBOTools.GenericDevice","text":"GenericDevice\n\nA thin wrapper around a Model that fulfills the AbstractDevice interface.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.Layout\nQUBOTools.layout","category":"page"},{"location":"api/#QUBOTools.Layout","page":"API Reference","title":"QUBOTools.Layout","text":"Layout\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.layout","page":"API Reference","title":"QUBOTools.layout","text":"layout(::Any)\nlayout(::Any, ::G) where {G<:AbstractGraph}\n\nReturns the layout of a model, device architecture, i.e., a description of the geometrical placement of each site as long as the network of their connections.\n\n\n\n\n\n","category":"function"},{"location":"api/#Problem-Synthesis","page":"API Reference","title":"Problem Synthesis","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractProblem\nQUBOTools.generate","category":"page"},{"location":"api/#QUBOTools.AbstractProblem","page":"API Reference","title":"QUBOTools.AbstractProblem","text":"AbstractProType{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.generate","page":"API Reference","title":"QUBOTools.generate","text":"generate(problem)\ngenerate(rng, problem)\n\nGenerates a QUBO problem and returns it as a Model.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.SherringtonKirkpatrick\nQUBOTools.Wishart","category":"page"},{"location":"api/#QUBOTools.SherringtonKirkpatrick","page":"API Reference","title":"QUBOTools.SherringtonKirkpatrick","text":"SherringtonKirkpatrick{T}(n::Integer, μ::T, σ::T)\n\nGenerates a Sherrington-Kirkpatrick model in n variables. Coefficients are normally distributed with mean mu and variance sigma.\n\n\n\n\n\n","category":"type"},{"location":"api/#QUBOTools.Wishart","page":"API Reference","title":"QUBOTools.Wishart","text":"Wishart{T}(n::Integer, m::Integer)\n\nRepresents the Wishart model on n variables whose mathbfW matrix has m columns.\n\nWhen true, the discretize keyword limits the entries of the mathbfR matrix to pm 1. The precision, on the other hand, is the amount of digits to round each entry R_ij after sampling from a normal distribution mathcalN(0 1).\n\n\n\n\n\n","category":"type"},{"location":"api/#Solution-Metrics","page":"API Reference","title":"Solution Metrics","text":"","category":"section"},{"location":"api/#Timing","page":"API Reference","title":"Timing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.total_time\nQUBOTools.effective_time","category":"page"},{"location":"api/#QUBOTools.total_time","page":"API Reference","title":"QUBOTools.total_time","text":"total_time(sol::AbstractSolution)\n\nRetrieves the total time spent during the whole solution gathering process, as experienced by the user.\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.effective_time","page":"API Reference","title":"QUBOTools.effective_time","text":"effective_time(sol::AbstractSolution)\n\nRetrieves the time spent by the algorithm in the strict sense, that is, excluding time spent with data access, precompilation and other activities. That said, it is assumed that t_texteffective le t_texttotal.\n\n\n\n\n\n","category":"function"},{"location":"api/#Solution-Quality","page":"API Reference","title":"Solution Quality","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.success_rate","category":"page"},{"location":"api/#QUBOTools.success_rate","page":"API Reference","title":"QUBOTools.success_rate","text":"success_rate(sol::AbstractSolution{T}, λ::T) where {T}\n\nReturns the success rate according to the given solution and the target objective value lambda.\n\n\n\n\n\n","category":"function"},{"location":"api/#Time-to-Target-(TTT)","page":"API Reference","title":"Time-to-Target (TTT)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.time_to_target\nQUBOTools.ttt","category":"page"},{"location":"api/#QUBOTools.time_to_target","page":"API Reference","title":"QUBOTools.time_to_target","text":"time_to_target(sol::AbstractSolution{T}, λ::T, s::Float64=0.99) where {T}\n\nComputes the time-to-target (TTT) given the solution and the target threshold lambda. The success factor s defaults to 099.\n\ntime_to_target(t::Float64, p::Float64, s::Float64=0.99)\n\nComputes the time-to-target (TTT) given the effective time t spent running the algorithm and the success probability p. The success factor s defaults to 099.\n\ntextttt(t p s) = t fraclog(1 - s)log(1 - p)\n\n\n\n\n\n","category":"function"},{"location":"api/#QUBOTools.ttt","page":"API Reference","title":"QUBOTools.ttt","text":"ttt\n\nAlias for time_to_target.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hamming-Distance","page":"API Reference","title":"Hamming Distance","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.hamming_distance","category":"page"},{"location":"api/#QUBOTools.hamming_distance","page":"API Reference","title":"QUBOTools.hamming_distance","text":"hamming_distance(x::Vector{U}, y::Vector{U}) where {U}\nhamming_distance(x::Sample{T,U}, y::Sample{T,U}) where {T,U}\n\n\n\n\n\n","category":"function"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QUBOTools.AbstractVisualization","category":"page"},{"location":"api/#QUBOTools.AbstractVisualization","page":"API Reference","title":"QUBOTools.AbstractVisualization","text":"AbstractVisualization\n\nRepresents a conceptual visualization built from a set of data structures. Its realization may combine multiple plot recipes as well.\n\nExamples\n\nModel Density Heatmap\n\njulia> using Plots\n\njulia> p = QUBOTools.ModelDensityPlot(model)\n\njulia> plot(p)\n\nSolution Energy vs. Frequency\n\njulia> using Plots\n\njulia> s = QUBOTools.solution(model)\n\njulia> p = QUBOTools.EnergyFrequencyPlot(s)\n\njulia> plot(p)\n\nor simply,\n\njulia> using Plots\n\njulia> p = QUBOTools.EnergyFrequencyPlot(model)\n\njulia> plot(p)\n\n\n\n\n\n","category":"type"},{"location":"manual/7-analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"manual/7-analysis/#Models","page":"Analysis","title":"Models","text":"","category":"section"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"using Random\n\nRandom.seed!(0)","category":"page"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"using QUBOTools\n\nn = 8\n\n# Generates a Sherrington-Kirpatrick model\nmodel = QUBOTools.generate(QUBOTools.SK(n))","category":"page"},{"location":"manual/7-analysis/#Model-Density","page":"Analysis","title":"Model Density","text":"","category":"section"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"using Plots\n\nplot(QUBOTools.ModelDensityPlot(model))","category":"page"},{"location":"manual/7-analysis/#System-Layout","page":"Analysis","title":"System Layout","text":"","category":"section"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"plot(QUBOTools.SystemLayoutPlot(model))","category":"page"},{"location":"manual/7-analysis/#Solutions","page":"Analysis","title":"Solutions","text":"","category":"section"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"function magical_solution_method(model, k = 30)\n    n = QUBOTools.dimension(model)\n\n    samples = Sample{Float64,Int}[]\n\n    for _ = 1:k\n        ψ = rand(0:1, n)\n        λ = QUBOTools.value(model, ψ)\n        r = rand(1:10)\n\n        push!(samples, Sample(ψ, λ, r))\n    end\n\n    return SampleSet(samples)\nend","category":"page"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"solution = magical_solution_method(model)","category":"page"},{"location":"manual/7-analysis/#Energy-Frequency","page":"Analysis","title":"Energy Frequency","text":"","category":"section"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"λ = minimum(QUBOTools.value, solution) # threshold\n\nplot(QUBOTools.EnergyFrequencyPlot(solution, λ))","category":"page"},{"location":"manual/7-analysis/#Energy-Distribution","page":"Analysis","title":"Energy Distribution","text":"","category":"section"},{"location":"manual/7-analysis/","page":"Analysis","title":"Analysis","text":"plot(QUBOTools.EnergyDistributionPlot(solution))","category":"page"},{"location":"manual/5-formats/#File-Formats","page":"File Formats","title":"File Formats","text":"","category":"section"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"Format Read Write Model Solutions Start Metadata\nBQPJSON ✅ ✅ ✅ ✅ ❌ ✅\nQUBin ✅ ✅ ✅ ✅ ✅ ✅\nQubist ✅ ✅ ✅ ❌ ❌ ❌\nQUBO ✅ ✅ ✅ ❌ ❌ ✅","category":"page"},{"location":"manual/5-formats/#Defining-a-Custom-File-Format","page":"File Formats","title":"Defining a Custom File Format","text":"","category":"section"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"using QUBOTools\n\nstruct SuperFormat <: QUBOTools.AbstractFormat\n    super::Bool\n\n    SuperFormat(super::Bool = true) = new(super)\nend","category":"page"},{"location":"manual/5-formats/#Writing-Models","page":"File Formats","title":"Writing Models","text":"","category":"section"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"To write a model using SuperFormat, one must implement the","category":"page"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"QUBOTools.write_model(io::IO, ::QUBOTools.AbstractModel{V,T,U}, ::SuperFormat) where {V,T,U}","category":"page"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"method for the custom format.","category":"page"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"info: Info\nThis assumption is valid for text-based and binary formats. If you pretend to write in a format that does not rely on io::IO (such as QUBOTools.QUBin), you should also implementQUBOTools.write_model(filepath::AbstractString, ::QUBOTools.AbstractModel{V,T,U}, ::SuperFormat) where {V,T,U}","category":"page"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"function QUBOTools.write_model(io::IO, model::QUBOTools.AbstractModel, fmt::SuperFormat)\n    if fmt.super\n        println(io, \"Format Type: SUPER\")\n\n        _write_super_model(io, model)\n    else\n        println(io, \"Format Type: Regular\")\n\n        _write_regular_model(io, model)\n    end\n    \n    return nothing\nend","category":"page"},{"location":"manual/5-formats/#Reading-Models","page":"File Formats","title":"Reading Models","text":"","category":"section"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"function QUBOTools.read_model(io::IO, fmt::SuperFormat)\n    header = readline(io)\n\n    if fmt.super\n        @assert(\"SUPER\" in header, \"Invalid header: '$header' is not SUPER!\")\n\n        return _read_super_model(io)\n    else\n        return _read_regular_model(io)\n    end\nend","category":"page"},{"location":"manual/5-formats/","page":"File Formats","title":"File Formats","text":"info: Info\nQUBOTools.read_model should return a QUBOTools.Model instance.","category":"page"},{"location":"formats/QUBin/#QUBin","page":"QUBin","title":"QUBin","text":"","category":"section"},{"location":"formats/QUBin/#Format","page":"QUBin","title":"Format","text":"","category":"section"},{"location":"formats/QUBin/","page":"QUBin","title":"QUBin","text":"QUBOTools.QUBin","category":"page"},{"location":"formats/QUBin/#QUBOTools.QUBin","page":"QUBin","title":"QUBOTools.QUBin","text":"QUBin()\n\nHDF5-based reference format for storing QUBOTools models and solutions.\n\n\n\n\n\n","category":"type"},{"location":"formats/Qubist/#Qubist","page":"Qubist","title":"Qubist","text":"","category":"section"},{"location":"formats/Qubist/#Format","page":"Qubist","title":"Format","text":"","category":"section"},{"location":"formats/Qubist/","page":"Qubist","title":"Qubist","text":"QUBOTools.Qubist","category":"page"},{"location":"formats/Qubist/#QUBOTools.Qubist","page":"Qubist","title":"QUBOTools.Qubist","text":"Qubist()\n\n\n\n\n\n","category":"type"},{"location":"formats/Qubist/#Example","page":"Qubist","title":"Example","text":"","category":"section"},{"location":"formats/Qubist/","page":"Qubist","title":"Qubist","text":"7 2\n1 1 0.75\n2 2 -3.0\n3 3 1.25\n1 2 1.0\n1 3 1.0\n2 3 1.0","category":"page"},{"location":"manual/2-math/#Mathematical-Formulation","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"","category":"section"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"This package's mathematical formulation conventions were inspired by BQPJSON's.","category":"page"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"min vert max f(mathbfx) = alpha left sum_i  j Q_i j x_i x_j + sum_i ell_i x_i + beta right","category":"page"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"where alpha beta in mathbbR are the scale and offset parameters. The vector mathbfell in mathbbR^n stores the linear terms and Q in mathbbR^n times n, the quadratic interaction matrix, is assumed to be strictly upper triangular.","category":"page"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"info: Info\nInternally, any problem loaded with this package will be converted to the normal form presented above.","category":"page"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"info: Info\nThe scaling factor alpha must be positive.","category":"page"},{"location":"manual/2-math/#Variable-Domains","page":"Mathematical Formulation","title":"Variable Domains","text":"","category":"section"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"Available domains are represented by the BoolDomain and SpinDomain types, respectively, x in mathbbB = lbrace 0 1 rbrace and s in mathbbS = lbrace -1 1 rbrace.","category":"page"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"Conversion between domains follows the identity:","category":"page"},{"location":"manual/2-math/","page":"Mathematical Formulation","title":"Mathematical Formulation","text":"leftlbracebeginalign*\n    s = 2x - 1          \n    x = fracs + 12\nendalign*right","category":"page"},{"location":"formats/BQPJSON/#BQPJSON","page":"BQPJSON","title":"BQPJSON","text":"","category":"section"},{"location":"formats/BQPJSON/#Format","page":"BQPJSON","title":"Format","text":"","category":"section"},{"location":"formats/BQPJSON/","page":"BQPJSON","title":"BQPJSON","text":"QUBOTools.BQPJSON","category":"page"},{"location":"formats/BQPJSON/#QUBOTools.BQPJSON","page":"BQPJSON","title":"QUBOTools.BQPJSON","text":"BQPJSON(; version::VersionNumber, indent::Integer)\n\nPrecise and detailed information found in the bqpjson docs\n\n\n\n\n\n","category":"type"},{"location":"formats/BQPJSON/#Example","page":"BQPJSON","title":"Example","text":"","category":"section"},{"location":"formats/BQPJSON/","page":"BQPJSON","title":"BQPJSON","text":"{\n    \"id\": 2,\n    \"version\": \"1.0.0\",\n    \"description\": \"Simple QUBO Problem\",\n    \"scale\": 2.7,\n    \"offset\": 1.93,\n    \"linear_terms\": [\n        {\n            \"id\": 1,\n            \"coeff\": 0.0\n        },\n        {\n            \"id\": 3,\n            \"coeff\": 0.4\n        },\n        {\n            \"id\": 5,\n            \"coeff\": -4.4\n        }\n    ],\n    \"quadratic_terms\": [\n        {\n            \"id_head\": 1,\n            \"coeff\": -0.8,\n            \"id_tail\": 3\n        },\n        {\n            \"id_head\": 1,\n            \"coeff\": 6.0,\n            \"id_tail\": 5\n        }\n    ],\n    \"variable_domain\": \"boolean\",\n    \"variable_ids\": [\n        1,\n        3,\n        5\n    ],\n    \"metadata\": {},\n    \"solutions\": [\n        {\n            \"evaluation\": 6.291,\n            \"id\": 0,\n            \"assignment\": [\n                {\n                    \"id\": 1,\n                    \"value\": 0\n                },\n                {\n                    \"id\": 3,\n                    \"value\": 1\n                },\n                {\n                    \"id\": 5,\n                    \"value\": 0\n                }\n            ],\n            \"description\": \"first solution\"\n        },\n        {\n            \"evaluation\": 9.531,\n            \"id\": 1,\n            \"assignment\": [\n                {\n                    \"id\": 1,\n                    \"value\": 1\n                },\n                {\n                    \"id\": 3,\n                    \"value\": 0\n                },\n                {\n                    \"id\": 5,\n                    \"value\": 1\n                }\n            ],\n            \"description\": \"second solution\"\n        }\n    ]\n}","category":"page"},{"location":"manual/6-solutions/#Solutions","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"A solution, as defined by the QUBOTools.AbstractSolution interface, is an ordered set of samples.","category":"page"},{"location":"manual/6-solutions/#Sample-records","page":"Solutions","title":"Sample records","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"A solution instance should contain an array of samples, where each sample is a 3-tuple (psi lambda r). Moreover, psi in mathbbU^n sim mathbbB^n is the sampled vector, lambda in mathbbR is the associated energy value and r in mathbbN is the number of reads, i. e., the multiplicity of the sample. Samples should be sorted by increasing values of lambda, then by decreasing the number of reads, and lastly by increasing the lexicographic order of their state vectors.","category":"page"},{"location":"manual/6-solutions/#Reference-Implementation","page":"Solutions","title":"Reference Implementation","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"Optimization results and metadata are stored in a specialized data structre, the QUBOTools.SampleSet.","category":"page"},{"location":"manual/6-solutions/#Metadata","page":"Solutions","title":"Metadata","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"The solution metadata should be stored in a JSON-compatible associative map with string keys, such as Dict{String,Any}.","category":"page"},{"location":"manual/6-solutions/#Timing","page":"Solutions","title":"Timing","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"We define two different time measures to evaluate the solution methods, namely the total time and the effective time. The \"time\" entry in the solution metadata dictionary is reserved and should be used solely to store the values of these measurements. When present, it must be itself a dictionary with positive numeric values.","category":"page"},{"location":"manual/6-solutions/#Total-Time","page":"Solutions","title":"Total Time","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"This measurement accounts for the complete sampling period, including: data manipulation, connection with the solver, problem embedding, solution post-processing, and other related tasks. The \"total\" entry in the \"time\" dictionary is reserved for it.","category":"page"},{"location":"manual/6-solutions/#Effective-Time","page":"Solutions","title":"Effective Time","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"Aimed at recording the time spent exclusively by the solving method, e.g., the actual usage of a Quantum Processing Unit (QPU). It will be stored in the the \"effective\" entry in the \"time\" dictionary.","category":"page"},{"location":"manual/6-solutions/#Other-Measurements","page":"Solutions","title":"Other Measurements","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"Solution platforms will commonly provide additional timing information with varying levels of granularity. Besides the \"total\" and \"effective\" keys, other fields can be used for solver-specific data without major caveats.","category":"page"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"For validation purposes, it is required that the total time is bigger than all other values stored. Since different time records might intersect, there are no restrictions regarding the sum of those.","category":"page"},{"location":"manual/6-solutions/#Origin","page":"Solutions","title":"Origin","text":"","category":"section"},{"location":"manual/6-solutions/","page":"Solutions","title":"Solutions","text":"When used, the \"origin\" field is a string referring to the method used for solving the problem, which could be the name of a cloud platform or even hardware identification details.","category":"page"},{"location":"#QUBOTools.jl","page":"Home","title":"QUBOTools.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The QUBOTools.jl package implements codecs and query methods for working with QUBO instances. Its purpose is to provide fast and reliable conversion between common formats used to represent such problems. This allows for rapid leverage of many emergent computing architectures whose job is to solve this kind of optimization problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QUBO term, in the strict sense, is widely used to indicate boolean problems of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrl\n       min  mathbfx Q mathbfx \ntextst  mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"with symmetric Q in mathbbR^n times n. Nevertheless, this package also provides full support for Ising Models, given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrl\n       min  mathbfs J mathbfs + mathbfh mathbfs \ntextst  mathbfs in leftlbrace-1 1rightrbrace^n\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"where J in mathbbR^n times n is upper triangular and mathbfh in mathbbR^n.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QUBOTools is avaible through Julia's General Registry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"QUBOTools\")\n\njulia> using QUBOTools","category":"page"},{"location":"#Design-Goals","page":"Home","title":"Design Goals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to provide:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast and reliable I/O, including conversion between formats.\nModel & Solution Analysis through data queries, metrics and plot recipes.\nGeneric yet complete backend for powering other applications.\nSynthetic problem generation.","category":"page"},{"location":"assets/README/#QUBOTools.jl's-Assets","page":"QUBOTools.jl's Assets","title":"QUBOTools.jl's Assets","text":"","category":"section"},{"location":"assets/README/#logo","page":"QUBOTools.jl's Assets","title":"Logo","text":"","category":"section"},{"location":"assets/README/","page":"QUBOTools.jl's Assets","title":"QUBOTools.jl's Assets","text":"QUBOTools's logo depicts the conversion between binary data and spin states. This represents the available codecs for manipulating Ising and QUBO models.","category":"page"},{"location":"assets/README/","page":"QUBOTools.jl's Assets","title":"QUBOTools.jl's Assets","text":"(Image: QUBOTools.jl)","category":"page"},{"location":"assets/README/#Colors","page":"QUBOTools.jl's Assets","title":"Colors","text":"","category":"section"},{"location":"assets/README/","page":"QUBOTools.jl's Assets","title":"QUBOTools.jl's Assets","text":"The colors were chosen according to  Julia's Reference for logo graphics¹. Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"assets/README/#Typography","page":"QUBOTools.jl's Assets","title":"Typography","text":"","category":"section"},{"location":"assets/README/","page":"QUBOTools.jl's Assets","title":"QUBOTools.jl's Assets","text":"Arial(#2) Font was used. It was chosen to represent the simplicity of this package.","category":"page"},{"location":"assets/README/","page":"QUBOTools.jl's Assets","title":"QUBOTools.jl's Assets","text":"<a href=\"#1\">¹</a> github.com/JuliaLang/julia-logo-graphics","category":"page"}]
}
