var documenterSearchIndex = {"docs":
[{"location":"assets/fonts/Sunflower-LICENSE/#Sunflower-Font-License","page":"Sunflower Font License","title":"Sunflower Font License","text":"","category":"section"},{"location":"assets/fonts/Sunflower-LICENSE/","page":"Sunflower Font License","title":"Sunflower Font License","text":"MadeType\nbehance.com/madetype\n\nhttps://www.fontspring.com/fonts/madetype\nhttps://creativemarket.com/MadeType\nhttps://www.youworkforthem.com/designer/1002/madetype/\nhttps://crella.net/store/madetype/\nhttps://thehungryjpeg.com/madetype\n\n\nEND USER LICENSE AGREEMENT\n\n- FOR PERSONAL USE. \n\n- Contact me at Madetypeinfo@gmail.com before commercial using it.\n\n- MadeType is not liable for any damage resulting from the use ot this typeface.\n\n- All rights are retained by MadeType.\n\n\nTHANK YOU!","category":"page"},{"location":"booklet/1-intro/#ToQUBO.jl-Booklet","page":"Introduction","title":"ToQUBO.jl Booklet","text":"","category":"section"},{"location":"booklet/1-intro/","page":"Introduction","title":"Introduction","text":"This booklet aims to gather the theoretical and practical details behind ToQUBO and provide documentation for project internals. The target audience includes, among others, advanced users and those willing to contribute to the project. The latter are advised to read the following sections, as they give a glimpse of the ideas employed up to now.","category":"page"},{"location":"booklet/1-intro/#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"booklet/1-intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"2-qubo.md\", \"3-pbo.md\", \"4-encoding.md\", \"5-virtual.md\", \"6-compiler.md\", \"7-solvers.md\", \"8-appendix.md\"]\nDepth = 2","category":"page"},{"location":"manual/3-results/#Gathering-Results","page":"Gathering Results","title":"Gathering Results","text":"","category":"section"},{"location":"manual/3-results/","page":"Gathering Results","title":"Gathering Results","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/4-encoding/#Encoding-Methods","page":"Encoding","title":"Encoding Methods","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Encoding.encode\nToQUBO.Encoding.encode!\nToQUBO.Encoding.encodes","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.encode","page":"Encoding","title":"ToQUBO.Encoding.encode","text":"encode(var, e::VariableEncodingMethod, x::Union{VI,Nothing}, S)\n\n\n\n\n\n","category":"function"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.encode!","page":"Encoding","title":"ToQUBO.Encoding.encode!","text":"encode!(target, source...)\n\n\n\n\n\n","category":"function"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.encodes","page":"Encoding","title":"ToQUBO.Encoding.encodes","text":"encodes(f::AbstractPBF, S::Tuple{T,T}, tol::T) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/4-encoding/#Variables","page":"Encoding","title":"Variables","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As you may already know, QUBO models are comprised only of binary variables. So when we are reformulating general optimization problems, one important step is to encode variables into binary ones.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO currently implements 6 encoding techniques. Each method introduces a different number of variables, quadratic terms and linear terms. Also, they differ in the magnitude of their coefficients Delta.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Encoding Binary Variables # Linear terms # Quadratic terms Delta\nBinary O(log n) O(log n) - O(n)\nUnary O(n) O(n) - O(1)\nOne-Hot O(n) O(n) O(n^2) O(n)\nDomain-Wall O(n) O(n) O(n) O(n)\nBounded-Coefficient O(n) O(n) - O(1)\nArithmetic Prog O(sqrtn) O(sqrtn) - O(sqrtn)","category":"page"},{"location":"booklet/4-encoding/#Mirror-Encoding","page":"Encoding","title":"Mirror Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Encoding.VariableEncodingMethod\nToQUBO.Encoding.Mirror","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.VariableEncodingMethod","page":"Encoding","title":"ToQUBO.Encoding.VariableEncodingMethod","text":"VariableEncodingMethod\n\nAbstract type for variable encoding methods.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.Mirror","page":"Encoding","title":"ToQUBO.Encoding.Mirror","text":"Mirror()\n\nSimply mirrors a binary variable x in mathbbB with a twin variable y in mathbbB.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Interval-Encoding","page":"Encoding","title":"Interval Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Encoding.IntervalVariableEncodingMethod\nToQUBO.Encoding.Unary\nToQUBO.Encoding.Binary\nToQUBO.Encoding.Arithmetic","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.IntervalVariableEncodingMethod","page":"Encoding","title":"ToQUBO.Encoding.IntervalVariableEncodingMethod","text":"IntervalVariableEncodingMethod\n\nAbstract type for methods that encode variables using a linear function, e.g.,\n\nxi(mathbfy) = beta + sum_i = 1^n gamma_i y_i\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.Unary","page":"Encoding","title":"ToQUBO.Encoding.Unary","text":"Unary{T}()\n\nInteger\n\nLet x in a b subset mathbbZ, n = b - a and mathbfy in mathbbB^n.\n\nxia b(mathbfy) = a + sum_j = 1^b - a y_j\n\nReal\n\nGiven n in mathbbN for x in a b subset mathbbR,\n\nxia b(mathbfy) = a + fracb - an sum_j = 1^n y_j\n\nRepresentation error\n\nGiven tau  0, for the expected encoding error to be less than or equal to tau, at least\n\nn ge 1 + fracb - a4 tau\n\nbinary variables become necessary.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.Binary","page":"Encoding","title":"ToQUBO.Encoding.Binary","text":"Binary{T}()\n\nInteger\n\nLet x in a b subset mathbbZ, n = leftlceil log_2(b - a) + 1 rightrceil and mathbfy in mathbbB^n.\n\nxia b(mathbfy) = a + left(b - a - 2^n - 1 + 1right) y_n + sum_j = 1^n - 1 2^j - 1 y_j\n\nReal\n\nGiven n in mathbbN for x in a b subset mathbbR,\n\nxia b(mathbfy) = a + fracb - a2^n - 1 sum_j = 1^n 2^j - 1 y_j\n\nRepresentation error\n\nGiven tau  0, for the expected encoding error to be less than or equal to tau, at least\n\nn ge log_2 left1 + fracb - a4 tauright\n\nbinary variables become necessary.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.Arithmetic","page":"Encoding","title":"ToQUBO.Encoding.Arithmetic","text":"Arithmetic{T}()\n\nInteger\n\nLet x in a b subset mathbbZ, n = leftlceil frac12 sqrt1 + 8 (b - a) - frac12 rightrceil and mathbfy in mathbbB^n.\n\nxia b(mathbfy) = a + left( b - a - fracn (n - 1)2 right) y_n + sum_j = 1^n - 1 j y_j\n\nReal\n\nGiven n in mathbbN for x in a b subset mathbbR,\n\nxia b(mathbfy) = a + fracb - an (n + 1) sum_j = 1^n j y_j\n\nRepresentation error\n\nGiven tau  0, for the expected encoding error to be less than or equal to tau, at least\n\nn ge frac12 left 1 + sqrt3 + frac(b - a)2 tau) right\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Bounded-Coefficients","page":"Encoding","title":"Bounded Coefficients","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Encoding.Bounded","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.Bounded","page":"Encoding","title":"ToQUBO.Encoding.Bounded","text":"Bounded{E,T}(μ::T) where {E<:Encoding,T}\n\nThe bounded-coefficient encoding method[Karimi2019] consists in limiting the magnitude of the coefficients in the encoding expansion to a parameter mu. This can be applied to the Unary, Binary and Arithmetic encoding methods.\n\nLet xia b  mathbbB^n to a b be an encoding function over the closed interval a b. The bounded-coefficient encoding function given mu is defined as\n\nxi_mua b = xi0 delta(y_1 dots y_k) + sum_j = k + 1^r mu yj\n\n[Karimi2019]: Karimi, S. & Ronagh, P. Practical integer-to-binary mapping for quantum annealers. Quantum Inf Process 18, 94 (2019). {doi}\n\n```\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Arbitrary-Set-Encoding","page":"Encoding","title":"Arbitrary Set Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Encoding.SetVariableEncodingMethod\nToQUBO.Encoding.OneHot\nToQUBO.Encoding.DomainWall","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.SetVariableEncodingMethod","page":"Encoding","title":"ToQUBO.Encoding.SetVariableEncodingMethod","text":"SetVariableEncodingMethod\n\nAbstract type for methods that encode variables over an arbitrary set.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.OneHot","page":"Encoding","title":"ToQUBO.Encoding.OneHot","text":"OneHot{T}()\n\nThe one-hot encoding is a linear technique used to represent a variable x in setgamma_j_j in n.\n\nThe associated encoding function is combined with a constraint assuring that only one and exactly one of the expansion's variables y_j is activated at a time.\n\nxisetgamma_j_j in n(mathbfy) = sum_j = 1^n gamma_j y_j textrmst sum_j = 1^n y_j = 1\n\nWhen a variable is encoded following this approach, a penalty term of the form\n\nrho left sum_j = 1^n y_j - 1 right^2\n\nis added to the objective function.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.DomainWall","page":"Encoding","title":"ToQUBO.Encoding.DomainWall","text":"DomainWall{T}()\n\nThe Domain Wall[Chancellor2019] encoding method is a sequential approach that requires n - 1 bits to represent n distinct values.\n\nxisetgamma_j_j in n(mathbfy) = sum_j = 1^n gamma_j (y_j - y_j + 1) textrmst sum_j = 1^n y_j oplus y_j + 1 = 1 y_1 = 1 y_n + 1 = 0\n\nwhere mathbfy in mathbbB^n + 1.\n\n[Chancellor2019]: Nicholas Chancellor, Domain wall encoding of discrete variables for quantum annealing and QAOA, Quantum Science Technology 4, 2019.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Representation-Error","page":"Encoding","title":"Representation Error","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Encoding.encoding_bits\nToQUBO.Encoding.encoding_points","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.encoding_bits","page":"Encoding","title":"ToQUBO.Encoding.encoding_bits","text":"encoding_bits(e::VariableEncodingMethod, S::Tuple{T,T}, tol::T) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/4-encoding/#ToQUBO.Encoding.encoding_points","page":"Encoding","title":"ToQUBO.Encoding.encoding_points","text":"encoding_points(e::SetVariableEncodingMethod, S::Tuple{T,T}, tol::T) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Let setx_i_i in k be the collection of k evenly spaced samples from the discretization of an interval a b subseteq mathbbR.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"The representation error for a given point x with respect to setx_i_i in k is","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"e_k(x) = min_i in k leftx - x_iright","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Assuming that x behaves as a uniformly distributed random variable, the expected absolute encoding error is","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"beginalign*\nmathbbElefte_k(x)right = frac1b - a int_a^b e_k(x) mathrmdx \n                              = frac14 fracb - ak - 1\nendalign*","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Thus, for encoding methods that rely on the regular division of an interval, it is possible to define the number of samples k necessary to limit the expected error according to an upper bound tau, that is,","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"mathbbElefte_k(x)right le tau implies k ge 1 + fracb - a4 tau","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"This allows the compiler to automatically infer the number of bits to allocate for an encoded variable given the tolerance factor.","category":"page"},{"location":"booklet/4-encoding/#Constraints","page":"Encoding","title":"Constraints","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"A QUBO model is unconstrained. So when ToQUBO is reformulating a problem, it needs to encode all constraints into the objective function losing as little information as possible.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As constraints are introduced into the objective function, we need to make sure that they won't be violated. In order to do that, ToQUBO multiplies the encoded constraint by a large penalty rho, so that any violation would result in a sub-optimal solution to the problem.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Sometimes, the encoding process might introduce higher-order terms, demanding ToQUBO to reduce the offending polynomials back to a quadratic form.","category":"page"},{"location":"manual/4-settings/#Compiler-Settings","page":"Compiler Settings","title":"Compiler Settings","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.StableCompilation","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.StableCompilation","page":"Compiler Settings","title":"ToQUBO.Attributes.StableCompilation","text":"StableCompilation()\n\nWhen set, this boolean flag enables stable reformulation methods, thus yielding predictable results.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Compiler-Messages","page":"Compiler Settings","title":"Compiler Messages","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Warnings","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Warnings","page":"Compiler Settings","title":"ToQUBO.Attributes.Warnings","text":"Warnings()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Compiler-Optimization","page":"Compiler Settings","title":"Compiler Optimization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Optimization","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Optimization","page":"Compiler Settings","title":"ToQUBO.Attributes.Optimization","text":"Optimization()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Working-with-target-architectures","page":"Compiler Settings","title":"Working with target architectures","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Architecture","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Architecture","page":"Compiler Settings","title":"ToQUBO.Attributes.Architecture","text":"Architecture()\n\nSelects which solver architecture to use. Defaults to QUBOTools.GenericArchitecture.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Quadratization","page":"Compiler Settings","title":"Quadratization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Quadratize\nToQUBO.Attributes.QuadratizationMethod\nToQUBO.Attributes.StableQuadratization","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Quadratize","page":"Compiler Settings","title":"ToQUBO.Attributes.Quadratize","text":"Quadratize()\n\nBoolean flag to conditionally perform the quadratization step. Is automatically set by the compiler when high-order functions are generated.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.QuadratizationMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.QuadratizationMethod","text":"QuadratizationMethod()\n\nDefines which quadratization method to use. Available options are defined in the PBO submodule.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.StableQuadratization","page":"Compiler Settings","title":"ToQUBO.Attributes.StableQuadratization","text":"StableQuadratization()\n\nWhen set, this boolean flag enables stable quadratization methods, thus yielding predictable results. This is intended to be used during tests or other situations where deterministic output is desired. On the other hand, usage in production is not recommended since it requires increased memory and processing resources.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Variable-and-Constraint-Encoding","page":"Compiler Settings","title":"Variable & Constraint Encoding","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.VariableEncodingBits\nToQUBO.Attributes.DefaultVariableEncodingBits\nToQUBO.Attributes.VariableEncodingATol\nToQUBO.Attributes.DefaultVariableEncodingATol\nToQUBO.Attributes.VariableEncodingMethod\nToQUBO.Attributes.DefaultVariableEncodingMethod\nToQUBO.Attributes.VariableEncodingPenalty\nToQUBO.Attributes.ConstraintEncodingPenalty","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingBits","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingBits","text":"VariableEncodingBits()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingBits","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingBits","text":"DefaultVariableEncodingBits()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingATol","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingATol","text":"VariableEncodingATol()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingATol","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingATol","text":"DefaultVariableEncodingATol()\n\nFallback value for VariableEncodingATol.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingMethod","text":"VariableEncodingMethod()\n\nAvailable methods are:\n\nEncoding.Binary (default)\nEncoding.Unary\nEncoding.Arithmetic\nEncoding.OneHot\nEncoding.DomainWall\nEncoding.Bounded\n\nThe Encoding.Binary, Encoding.Unary and Encoding.Arithmetic encodings can have their expansion coefficients bounded by wrapping them with the Encoding.Bounded method.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingMethod","text":"DefaultVariableEncodingMethod()\n\nFallback value for VariableEncodingMethod.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingPenalty","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingPenalty","text":"VariableEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding variables when additional constraints are involved.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.ConstraintEncodingPenalty","page":"Compiler Settings","title":"ToQUBO.Attributes.ConstraintEncodingPenalty","text":"ConstraintEncodingPenalty()\n\nAllows the user to retrieve the coefficients used for encoding constraints.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Discretization","page":"Compiler Settings","title":"Discretization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Discretize","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Discretize","page":"Compiler Settings","title":"ToQUBO.Attributes.Discretize","text":"Discretize()\n\nWhen set, this boolean flag guarantees that every coefficient in the final formulation is an integer.\n\n\n\n\n\n","category":"type"},{"location":"examples/portfolio_optimization/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"In this example, we will be exploring an optimization model for asset distribution where the expected return is maximized while mitigating the financial risk. The following approach was inspired by a JuMP tutorial, where monthly stock prices for three assets are provided, namely IBM, WMT and SEHI.","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"The modelling presented below aggregates the risk measurement mathbfx Sigma mathbfx as a penalty term to the objective function, thus yielding","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginarrayrll\n    max_mathbfx  mathbfmumathbfx - lambda mathbfx Sigma mathbfx             \n    textrmst      0 le x_i le 1                                                forall i \n                       sum_i x_i = 1\nendarray","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"where mu_i = mathbbEr_i is the expected return value for each investment i; Sigma is the covariance matrix and lambda is the risk-aversion penalty factor.","category":"page"},{"location":"examples/portfolio_optimization/#Stock-prices","page":"Portfolio Optimization","title":"Stock prices","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using DataFrames\nusing Statistics\n\nassets = [:IBM, :WMT, :SEHI]\n\ndf = DataFrames.DataFrame(\n    [\n         93.043    51.826    1.063\n         84.585    52.823    0.938\n        111.453    56.477    1.000\n         99.525    49.805    0.938\n         95.819    50.287    1.438\n        114.708    51.521    1.700\n        111.515    51.531    2.540\n        113.211    48.664    2.390\n        104.942    55.744    3.120\n         99.827    47.916    2.980\n         91.607    49.438    1.900\n        107.937    51.336    1.750\n        115.590    55.081    1.800\n    ],\n    assets,\n)","category":"page"},{"location":"examples/portfolio_optimization/#Solving","page":"Portfolio Optimization","title":"Solving","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using JuMP\nusing ToQUBO\nusing DWave\n\nfunction solve(\n    config!::Function,\n    df::DataFrame,\n    λ::Float64 = 10.;\n    optimizer = DWave.Neal.Optimizer\n)\n    # Number of assets\n    n = size(df, 2)\n\n    # Relative monthly return\n    r = diff(Matrix(df); dims = 1) ./ Matrix(df[1:end-1, :])\n\n    # Expected monthly return value for each stock\n    μ = vec(Statistics.mean(r; dims = 1))\n\n    # Covariance matrix\n    Σ = Statistics.cov(r)\n\n    # Build model\n    model = Model(() -> ToQUBO.Optimizer(optimizer))\n\n    @variable(model, 0 <= x[1:n] <= 1)\n    @objective(model, Max, μ'x - λ * x' * Σ * x)\n    @constraint(model, sum(x) == 1)\n\n    config!(model)\n\n    optimize!(model)\n\n    return value.(x)\nend\n\nfunction solve(df::DataFrame, λ::Float64 = 10.; optimizer = DWave.Neal.Optimizer)\n    return solve(identity, df, λ; optimizer)\nend","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"solve(df) do model\n    JuMP.set_silent(model)\n    JuMP.set_optimizer_attribute(model, \"num_reads\", 2_000)\nend","category":"page"},{"location":"examples/portfolio_optimization/#Penalty-Analysis","page":"Portfolio Optimization","title":"Penalty Analysis","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"To finish our discussion, we are going to sketch some graphics to help our reasoning on how the penalty factor lambda affects our investments.","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using Plots\nusing Measures\n\n# Make plots look professional\nPlots.default(;\n    fontfamily = \"Computer Modern\",\n    plot_titlefontsize  = 16,\n    titlefontsize       = 14,\n    guidefontsize       = 12,\n    legendfontsize      = 10,\n    tickfontsize        = 10,\n    margin              = 5mm,\n)","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using Plots\n\nΛ = collect(0.:5.:50.)\nX = Dict{Symbol,Vector{Float64}}(tag => [] for tag in assets)\n\nfor λ = Λ\n    x = solve(df, λ)\n\n    for (i, tag) in enumerate(assets)\n        push!(X[tag], x[i])\n    end\nend\n\nplt = plot(;\n    title=\"Portfolio Optimization\",\n    xlabel=raw\"penalty factor ($\\lambda$)\",\n    ylabel=raw\"investment share ($x$)\",\n)\n\nfor tag in assets\n    plot!(plt, Λ, X[tag]; label=string(tag))\nend\n\nplt","category":"page"},{"location":"booklet/3-pbo/#Pseudo-Boolean-Optimization","page":"PBO","title":"Pseudo-Boolean Optimization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"Internally, problems are represented through a Pseudo-Boolean Optimization (PBO) framework. The main goal is to represent a given problem using a Pseudo-Boolean Function (PBF) since there is an immediate correspondence between optimization over quadratic PBFs and the QUBO formalism.","category":"page"},{"location":"booklet/3-pbo/#Quadratization","page":"PBO","title":"Quadratization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"In order to successfully achieve a QUBO formulation, sometimes it is needed to quadratize the resulting PBF, i.e., reduce its degree until reaching the quadratic case. ","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"A quadratization is a mapping mathcalQ mathscrF to mathscrF^2 such that","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"forall f in mathscrF forall x in 0 1^n min_y mathcalQleftlbracefrightrbrace(x y) = f(x)","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"There are many quadratization methods available[Dattani2019], and ToQUBO implements two of them for now. However, using Julia's multiple dispatch paradigm, it's possible to extend the quadratization method coverage with your own algorithms.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"[Dattani2019]: Nikesh S. Dattani, Quadratization in discrete optimization and quantum mechanics, ArXiv, 2019 {doi}","category":"page"},{"location":"booklet/3-pbo/#Quadratization-Methods","page":"PBO","title":"Quadratization Methods","text":"","category":"section"},{"location":"booklet/3-pbo/#Stable-Quadratization","page":"PBO","title":"Stable Quadratization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"The quadratization of a PBF does not guarantee that the resulting function will always be the same, as the order of terms can be different each time. This can be an issue in some situations where a deterministic output is required.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"With said that, we have introduced the concept of Stable Quadratization, where the terms of the PBF are sorted, guaranteeing that the resulting PBF will be the same every time. We have defined it as an attribute of the compiler, with the  ToQUBO.Attributes.StableQuadratization flag.","category":"page"},{"location":"booklet/6-compiler/#The-Compiler","page":"The Compiler","title":"The Compiler","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/6-compiler/#Compilation-Steps","page":"The Compiler","title":"Compilation Steps","text":"","category":"section"},{"location":"booklet/6-compiler/#Setup","page":"The Compiler","title":"Setup","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.Compiler.reset!\nToQUBO.Compiler.setup!","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.reset!","page":"The Compiler","title":"ToQUBO.Compiler.reset!","text":"reset!(model::Virtual.Model, arch::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.setup!","page":"The Compiler","title":"ToQUBO.Compiler.setup!","text":"setup!(model::Virtual.Model, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#Parsing","page":"The Compiler","title":"Parsing","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.Compiler.parse!\nToQUBO.Compiler._parse","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.parse!","page":"The Compiler","title":"ToQUBO.Compiler.parse!","text":"parse!(\n    model::Virtual.Model{T},\n    g::PBO.PBF{VI,T},\n    f::MOI.AbstractFunction,\n    arch::AbstractArchitecture\n) where {T}\n\nParses the given MOI function f into PBF g.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler._parse","page":"The Compiler","title":"ToQUBO.Compiler._parse","text":"\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#Reformulation","page":"The Compiler","title":"Reformulation","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.Compiler.sense!\nToQUBO.Compiler.variable!\nToQUBO.Compiler.variables!\nToQUBO.Compiler.constraint\nToQUBO.Compiler.constraints!\nToQUBO.Compiler.objective!\nToQUBO.Compiler.penalties!","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.sense!","page":"The Compiler","title":"ToQUBO.Compiler.sense!","text":"sense!(model::Virtual.Model, ::AbstractArchitecture)\n\nCopies MOI.ObjectiveSense from model.source_model to model.target_model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.variable!","page":"The Compiler","title":"ToQUBO.Compiler.variable!","text":"variable!(model::Virtual.Model{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.variables!","page":"The Compiler","title":"ToQUBO.Compiler.variables!","text":"variables!(model::Virtual.Model{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.constraint","page":"The Compiler","title":"ToQUBO.Compiler.constraint","text":"constraint\n\nReturns the pseudo-boolean function associated to a given constraint from the source model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.constraints!","page":"The Compiler","title":"ToQUBO.Compiler.constraints!","text":"constraints!(model::Virtual.Model, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.objective!","page":"The Compiler","title":"ToQUBO.Compiler.objective!","text":"objective!(model::Virtual.Model, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.penalties!","page":"The Compiler","title":"ToQUBO.Compiler.penalties!","text":"penalties!(model::Virtual.Model, arch::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#Copying","page":"The Compiler","title":"Copying","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.Compiler.isqubo\nToQUBO.Compiler.copy!","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.isqubo","page":"The Compiler","title":"ToQUBO.Compiler.isqubo","text":"isqubo(model::MOI.ModelLike)\n\nTells if a given model is ready to be interpreted as a QUBO model.\n\nFor it to be true, a few conditions must be met:\n\nAll variables must be binary (MOI.VariableIndex ∈ MOI.ZeroOne)\nNo other constraints are allowed\nThe objective function must be of type MOI.ScalarQuadraticFunction, MOI.ScalarAffineFunction or MOI.VariableIndex\nThe objective sense must be either MOI.MIN_SENSE or MOI.MAX_SENSE\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.copy!","page":"The Compiler","title":"ToQUBO.Compiler.copy!","text":"copy!(model::Virtual.Model, arch::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#Hamiltonian-Assembly","page":"The Compiler","title":"Hamiltonian Assembly","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.Compiler.build!\nToQUBO.Compiler.quadratize!","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.build!","page":"The Compiler","title":"ToQUBO.Compiler.build!","text":"build!(model::Virtual.Model, arch::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.Compiler.quadratize!","page":"The Compiler","title":"ToQUBO.Compiler.quadratize!","text":"quadratize!(model::Virtual.Model, arch::AbstractArchitecture)\n\nQuadratizes the objective function from a model.\n\n\n\n\n\n","category":"function"},{"location":"manual/1-start/#Manual","page":"Getting Started","title":"Manual","text":"","category":"section"},{"location":"manual/1-start/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"manual/1-start/","page":"Getting Started","title":"Getting Started","text":"using JuMP\nusing ToQUBO\nusing DWave\n\nmodel = Model(() -> ToQUBO.Optimizer(DWave.Neal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n\n@objective(model, Max, 1.0 * x[1] + 2.0 * x[2] + 3.0 * x[3])\n\n@constraint(model, 0.3 * x[1] + 0.5 * x[2] + 1.0 * x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"manual/1-start/#Table-of-Contents","page":"Getting Started","title":"Table of Contents","text":"","category":"section"},{"location":"manual/1-start/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"2-model.md\", \"3-results.md\", \"4-settings.md\"]\nDepth = 2","category":"page"},{"location":"booklet/2-qubo/#QUBO","page":"QUBO","title":"QUBO","text":"","category":"section"},{"location":"booklet/2-qubo/#Definition","page":"QUBO","title":"Definition","text":"","category":"section"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Quadratic Unconstrained Binary Optimization, as the name suggests, refers to the global minimization or maximization of a quadratic polynomial on binary variables. A common presentation, the quadratic matrix form, is written as","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"beginarrayrl\n   min_mathbfx  mathbfx Qmathbfx \n   textrmst      mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"where Q in mathbbR^n times n is symmetric and mathbbB = lbrace0 1rbrace. Note that, since x^2 = x holds for x in mathbbB, the linear terms of the objective function are stored in the main diagonal of Q.","category":"page"},{"location":"booklet/2-qubo/#OK,-but-why-QUBO?","page":"QUBO","title":"OK, but why QUBO?","text":"","category":"section"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Mathematically speaking, there is a notorious equivalence between QUBO and Max-Cut problems, e.g. for every QUBO instance there is an information preserving Max-Cut reformulation and vice versa. This statement is followed by two immediate implications:","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"In the general case, solving QUBO globally is NP-Hard.\nIt is a simple yet expressive mathematical programming framework.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Implication 1. tells us that such problems are computationally intractable and that heuristics and metaheuristics are to be employed instead of exact methods. No 2. relates to the fact that we are able to represent many other optimization models by means of the QUBO formalism.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"The Ising Model, on the other hand, is a mathematical abstraction to describe statistical interactions within mechanical systems with interesting properties for encoding combinatorial problems. Its Hamiltonian leads to an optimization formulation in terms of the spin values of their states, given by","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"beginarrayrl\n   min_mathbfs  mathbfhmathbfs + mathbfs Jmathbfs \n   textrmst      mathbfs in lbrace-1+1rbrace^n\nendarray","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"with strictly upper triangular J in mathbbR^n times n and mathbfh in mathbbR.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"(Image: D-Wave Washington 1000Q)","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"The Ising reformulation alternative draws the bridge between QUBO problems and devices designed to sample global or approximate ground states of the Ising Hamiltonian with high probability[Mohseni2022]. Some of the paradigms that stand out in this context are quantum gate-based optimization algorithms (QAOA and VQE), quantum annealers, hardware-accelerated platforms (Coherent Ising Machines and Simulated Bifurcation Machines) and physics-inspired methods (Simulated Annealing, Parallel Tempering). The significant advances in these computing systems contributed to the growing popularity of the model across the literature.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"[Mohseni2022]: Mohseni, N., McMahon, P. L. & Byrnes, T. Ising machines as hardware solvers of combinatorial optimization problems. Nat Rev Phys 4, 363–379 (2022). {arXiv}","category":"page"},{"location":"booklet/8-appendix/#Appendix","page":"Appendix","title":"Appendix","text":"","category":"section"},{"location":"booklet/8-appendix/#ToQUBO.jl's-Assets","page":"Appendix","title":"ToQUBO.jl's Assets","text":"","category":"section"},{"location":"booklet/8-appendix/#Logo","page":"Appendix","title":"Logo","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The ideia behind ToQUBO.jl's logo comes from a wordplay in Portuguese and Spanish. The package's main purpose is to assemble QUBO Models, which sounds like cubo[1], the translation for cube.","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"(Image: ToQUBO.jl Logo)","category":"page"},{"location":"booklet/8-appendix/#Colors","page":"Appendix","title":"Colors","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The colors were picked according to  Julia's Reference for logo graphics[2]. Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"booklet/8-appendix/#Typography","page":"Appendix","title":"Typography","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The MADETYPE Sunflower[3] font was chosen. It was converted to a SVG path using the Google Font to Svg Path[4] online tool.","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[1]: IPA: [ˈkubʊ]","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[2]: github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[3]: Licensed by the authors for use in this project","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[4]: danmarshall.github.io/google-font-to-svg-path","category":"page"},{"location":"booklet/8-appendix/#Web-Icon-![ToQUBO.jl-Icon](../assets/favicon.ico)","page":"Appendix","title":"Web Icon (Image: ToQUBO.jl Icon)","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The icon used to decorate the documentation resembles an assembled version of the cube with its blue face making up the background.","category":"page"},{"location":"booklet/7-solvers/#QUBO-Solvers","page":"Solvers","title":"QUBO Solvers","text":"","category":"section"},{"location":"booklet/7-solvers/#Solvers,-Annealers-and-Samplers","page":"Solvers","title":"Solvers, Annealers & Samplers","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"ToQUBO.jl's main goal is to make use of parameterized stochastic optimization solvers, particularly those relying on non-conventional hardware such as Quantum Annealing and other Ising Machines. A few MOI-compliant interfaces for annealers and samplers are bundled within ToQUBO.jl via the QUBODrivers.jl companion package. Some of them are presented below.","category":"page"},{"location":"booklet/7-solvers/#Simulated-Annealing","page":"Solvers","title":"Simulated Annealing","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Provided by D-Wave's open-source code libraries, this Simulated Annealing engine implements some of the features and configurations you would find using the Quantum API. Its adoption is recommended for basic usage, tests, and research due to its robustness, simplicity and ease of use. The DWave.jl's DWave.Neal module uses QUBODrivers.jl to deliver an interface to this sampler.","category":"page"},{"location":"booklet/7-solvers/#Quantum-Annealing","page":"Solvers","title":"Quantum Annealing","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Interfacing with D-Wave's quantum annealer is one of the milestones we expect to achieve with this package. Like other proprietary optimization resources such as Gurobi, FICO® Xpress and IBM® CPLEX®, this requires licensing and extra steps are needed to get an access token. In a first moment, for those willing to get started, the DWave.Neal optimizer might be enough to learn the ropes.","category":"page"},{"location":"booklet/7-solvers/#Random-Sampling","page":"Solvers","title":"Random Sampling","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"This sampler is implemented for test purposes and simply assigns 0 or 1 to each variable according to a given probability bias 0 le p le 1, which defaults to p = 05. After running the using QUBODrivers command, RandomSampler.Optimizer will be available.","category":"page"},{"location":"booklet/7-solvers/#Exact-Solver-(Exhaustive-Enumeration)","page":"Solvers","title":"Exact Solver (Exhaustive Enumeration)","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Also made to be used in tests, the ExactSolver.Optimizer interface runs through all possible state configurations, which implies in an exponential time complexity on the number of variables. Thus, only problems with at most approxeq 20 variables should be provided since visiting 2^20 approxeq 10^6 states can already take up to a few seconds.","category":"page"},{"location":"booklet/7-solvers/#Mixed-Integer-Quadratic-Programming","page":"Solvers","title":"Mixed-Integer Quadratic Programming","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"The most accessible alternative to the forementioned methods are Mixed-Integer Quadratic Programming (MIQP) solvers such as Gurobi, CPLEX, SCIP and BARON. These are not intended to be of regular use alongside ToQUBO.jl since providing a QUBO reformulation will usually make things harder for non-specialized solvers. Yet, there are still a few cases where they may be suitable, such as tests, benchmarks, or any other situation where global optimality is a must.","category":"page"},{"location":"manual/2-model/#Running-a-Model","page":"Running a Model","title":"Running a Model","text":"","category":"section"},{"location":"manual/2-model/","page":"Running a Model","title":"Running a Model","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/5-virtual/#Virtual-Mapping","page":"Virtual Mapping","title":"Virtual Mapping","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"During reformulation, ToQUBO holds two distinct models, namely the Source Model and the Target Model. The source model is a generic MOI model restricted to the supported constraints. The target one is on the QUBO form used during the solving process. Both lie within a Virtual Model, which provides the necessary API integration and keeps all variable and constraint mapping tied together.","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"This is done in a transparent fashion for both agents since the user will mostly interact with the presented model, and the solvers will only access the generated one.","category":"page"},{"location":"booklet/5-virtual/#Virtual-Model","page":"Virtual Mapping","title":"Virtual Model","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.Virtual.Model","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.Model","page":"Virtual Mapping","title":"ToQUBO.Virtual.Model","text":"Model{T}(optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing) where {T}\n\nThis Virtual Model links the final QUBO formulation to the original one, allowing variable value retrieving and other features.\n\n\n\n\n\n","category":"type"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.Virtual.source\nToQUBO.Virtual.target","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.source","page":"Virtual Mapping","title":"ToQUBO.Virtual.source","text":"source\n\n\n\n\n\n","category":"function"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.target","page":"Virtual Mapping","title":"ToQUBO.Virtual.target","text":"target\n\n\n\n\n\n","category":"function"},{"location":"booklet/5-virtual/#Virtual-Variables","page":"Virtual Mapping","title":"Virtual Variables","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"Every virtual model stores a collection of virtual variables, intended to provide a link between those in the source and those to be created in the target model. Each virtual variable stores encoding information for later expansion and evaluation.","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.Virtual.Variable","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.Variable","page":"Virtual Mapping","title":"ToQUBO.Virtual.Variable","text":"Variable{T}\n\n\n\n\n\n","category":"type"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.Virtual.encoding\nToQUBO.Virtual.expansion\nToQUBO.Virtual.penaltyfn","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.encoding","page":"Virtual Mapping","title":"ToQUBO.Virtual.encoding","text":"encoding\n\n\n\n\n\n","category":"function"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.expansion","page":"Virtual Mapping","title":"ToQUBO.Virtual.expansion","text":"expansion\n\n\n\n\n\n","category":"function"},{"location":"booklet/5-virtual/#ToQUBO.Virtual.penaltyfn","page":"Virtual Mapping","title":"ToQUBO.Virtual.penaltyfn","text":"penaltyfn\n\n\n\n\n\n","category":"function"},{"location":"#ToQUBO.jl-Documentation","page":"Home","title":"ToQUBO.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ToQUBO.jl is a Julia Package intended to automatically translate models written in JuMP, into the QUBO mathematical optimization framework.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"ToQUBO\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing ToQUBO\nusing DWave\n\nmodel = Model(() -> ToQUBO.Optimizer(DWave.Neal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n@objective(model, Max, 1.0*x[1] + 2.0*x[2] + 3.0*x[3])\n@constraint(model, 0.3*x[1] + 0.5*x[2] + 1.0*x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"#Citing-ToQUBO.jl","page":"Home","title":"Citing ToQUBO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ToQUBO.jl in your work, we kindly ask you to include the following citation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{toqubo:2023,\n  author       = {Pedro Maciel Xavier and Pedro Ripper and Tiago Andrade and Joaquim Dias Garcia and David E. Bernal Neira},\n  title        = {{ToQUBO.jl}},\n  month        = {feb},\n  year         = {2023},\n  publisher    = {Zenodo},\n  version      = {v0.1.5},\n  doi          = {10.5281/zenodo.7644291},\n  url          = {https://doi.org/10.5281/zenodo.7644291}\n}","category":"page"},{"location":"examples/integer_factorization/#Prime-Factorization","page":"Integer Factorization","title":"Prime Factorization","text":"","category":"section"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"A central problem in Number Theory and cryptography is to factor R in mathbbN, which is known to be the product of two distinct prime numbers p q in mathbbN. Shor's Algorithm, designed to address such task is often regarded as one of the major theoretical landmarks in Quantum Computing, being responsible for driving increasingly greater interest to the area.","category":"page"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"A naïve approach to model this problem can be stated as a quadratically-constrained integer program:","category":"page"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"beginarrayrl\ntextst  p times q = R \n             p q ge 0     \n             p q in mathbbZ\nendarray","category":"page"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"From the definition and the basics of number theory, we are able to retrieve a few assumptions about the problem's variables:","category":"page"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"p and q are bounded to the interval left1 Rright\nMoreover, it is fine to assume 1  p le sqrtR le q le R div 2.","category":"page"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"using JuMP\nusing ToQUBO\nusing DWave\n\nfunction factor(R::Integer; optimizer = DWave.Neal.Optimizer)\n    return factor(identity, R; optimizer)\nend\n\nfunction factor(config!::Function, R::Integer; optimizer = DWave.Neal.Optimizer)\n    model = Model(() -> ToQUBO.Optimizer(optimizer))\n\n    @variable(model,  1 <= p <= √R, Int)\n    @variable(model, √R <= q <= R ÷ 2, Int)\n\n    @constraint(model, p * q == R)\n\n    config!(model)\n\n    optimize!(model)\n\n    p = round(Int, value(model[:p]))\n    q = round(Int, value(model[:q]))\n\n    return (p, q)\nend","category":"page"},{"location":"examples/integer_factorization/","page":"Integer Factorization","title":"Integer Factorization","text":"p, q = factor(15) do model\n    set_optimizer_attribute(model, \"num_reads\", 1_000)\n    set_optimizer_attribute(model, \"num_sweeps\", 2_000)\nend\n\nprint(\"$p, $q\")","category":"page"},{"location":"examples/knapsack/#Knapsack","page":"Knapsack","title":"Knapsack","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We start with some instances of the discrete Knapsack Problem whose standard formulation is","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"beginarrayr l\n    max         mathbfc mathbfx \n    textst  mathbfw mathbfx le C \n                mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"First, consider the following items","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Item (i) Value (c_i) Weight (w_i)\n1 1 0.3\n2 2 0.5\n3 3 1.0","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"to be carried in a knapsack with capacity C = 16.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Writing down the data above as a linear program, we have","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"beginarrayr l\n    max         x_1 + 2 x_2 + 3 x_3 \n    textst  03 x_1 + 05 x_2 + x_3 le 16 \n                mathbfx in mathbbB^3\nendarray","category":"page"},{"location":"examples/knapsack/#Simple-JuMP-Model","page":"Knapsack","title":"Simple JuMP Model","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Writing this in JuMP we end up with","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using JuMP\nusing ToQUBO\nusing DWave\n\nmodel = Model(() -> ToQUBO.Optimizer(DWave.Neal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n@objective(model, Max, x[1] + 2 * x[2] + 3 * x[3])\n@constraint(model, 0.3 * x[1] + 0.5 * x[2] + x[3] ≤ 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"The final decision is to take items 2 and 3, i.e., x_1 = 0 x_2 = 1 x_3 = 1.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"value.(x)","category":"page"},{"location":"examples/knapsack/#Using-DataFrames","page":"Knapsack","title":"Using DataFrames","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Now, lets fill a few more knapsacks. First, we generate uniform random costs mathbfc and weights mathbfw then set the knapsack's capacity C to be a fraction of the total available weight i.e. 80.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"This example was inspired by D-Wave's knapsack example repository.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\nusing Random\n\n# Generate Data\nrng = MersenneTwister(1)\n\ndf = DataFrame(\n   :cost   => rand(rng, 1:100, 8),\n   :weight => rand(rng, 1:100, 8),\n)\n\nCSV.write(\"knapsack.csv\", df)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\n\ndf = CSV.read(\"knapsack.csv\", DataFrame)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using JuMP\nusing ToQUBO\nusing DWave\n\nmodel = Model(() -> ToQUBO.Optimizer(DWave.Neal.Optimizer))\n\nn = size(df, 1)\nc = collect(Float64, df[!, :cost])\nw = collect(Float64, df[!, :weight])\nC = round(0.8 * sum(w))\n\n@variable(model, x[1:n], Bin)\n@objective(model, Max, c' * x)\n@constraint(model, w' * x <= C)\n\noptimize!(model)\n\n# Add Results as a new column\ndf[:,:select] = map(xi -> ifelse(xi > 0, \"✅\", \"❌\"), value.(x))\n\ndf","category":"page"}]
}
